#!/bin/bash
# GeuseMaker UserData Script - {{ stack_name }}
# Generated for tier: {{ tier }}
# Region: {{ region }}

set -euo pipefail

# Logging setup
LOGFILE="/var/log/geusemaker-userdata.log"
exec 1> >(tee -a "$LOGFILE")
exec 2>&1

echo "==================================="
echo "GeuseMaker UserData Initialization"
echo "Stack: {{ stack_name }}"
echo "Tier: {{ tier }}"
echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
echo "==================================="

# Guard file to prevent re-running on reboot
GUARD_FILE="/var/lib/geusemaker/userdata-complete"
ERROR_GUARD="/var/lib/geusemaker/userdata-error"
if [ -f "$GUARD_FILE" ]; then
    echo "UserData already executed, skipping (idempotency guard)"
    exit 0
fi

# Create state directory
mkdir -p /var/lib/geusemaker
rm -f "$ERROR_GUARD"

# Error handler
handle_error() {
    local line_num="${1:-unknown}"
    echo "ERROR: UserData script failed at line $line_num"
    echo "Check $LOGFILE for details"
    echo "$(date -u +%Y-%m-%dT%H:%M:%SZ): failed at line $line_num" > "$ERROR_GUARD"
    exit 1
}

trap 'handle_error ${LINENO:-unknown}' ERR

echo "Starting GeuseMaker initialization..."

# Runtime bundle setup (optional)
GEUSEMAKER_RUNTIME_DIR="/opt/geusemaker/runtime"
COMPOSE_FILE_PATH="/root/docker-compose.yml"
mkdir -p "$GEUSEMAKER_RUNTIME_DIR"

{% if use_runtime_bundle %}
RUNTIME_BUNDLE_FILE="$GEUSEMAKER_RUNTIME_DIR/{{ runtime_bundle_filename }}"
echo "Unpacking runtime bundle into $GEUSEMAKER_RUNTIME_DIR"
cat <<"__GEUSE_BUNDLE__" | base64 -d > "$RUNTIME_BUNDLE_FILE"
{{ runtime_bundle_b64 }}
__GEUSE_BUNDLE__
tar -xzf "$RUNTIME_BUNDLE_FILE" -C "$GEUSEMAKER_RUNTIME_DIR"
COMPOSE_FILE_PATH="$GEUSEMAKER_RUNTIME_DIR/docker-compose.yml"
{% else %}
RUNTIME_BUNDLE_FILE=""
{% endif %}
RUNTIME_ENV_FILE="$(dirname "$COMPOSE_FILE_PATH")/runtime.env"
export GEUSEMAKER_RUNTIME_DIR COMPOSE_FILE_PATH RUNTIME_ENV_FILE

# OS detection and package helpers
detect_os_family() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "${ID,,}" in
            amzn|amzn2|amzn2023)
                echo "amazon"
                return
                ;;
            ubuntu|debian)
                echo "debian"
                return
                ;;
        esac
    fi
    echo "unknown"
}

OS_FAMILY="$(detect_os_family)"
if [ "$OS_FAMILY" = "unknown" ]; then
    echo "ERROR: Unsupported OS. Only Amazon Linux and Ubuntu are supported."
    exit 1
fi

echo "Detected OS family: $OS_FAMILY"

# Debian/Ubuntu: set noninteractive frontend and add dpkg/apt lock retry helper
if [ "$OS_FAMILY" = "debian" ]; then
    export DEBIAN_FRONTEND=noninteractive
fi

with_dpkg_lock_retry() {
    if [ "$OS_FAMILY" != "debian" ]; then
        "$@"
        return $?
    fi

    local attempt=1
    local max_attempts=30
    local sleep_seconds=10
    local output
    while true; do
        if output=$("$@" 2>&1); then
            printf "%s\n" "$output"
            return 0
        fi
        local status=$?
        printf "%s\n" "$output"
        if echo "$output" | grep -Eq "Could not get lock /var/lib/(dpkg/lock(-frontend)?|apt/lists/lock)|Unable to acquire the dpkg frontend lock"; then
            if [ "$attempt" -ge "$max_attempts" ]; then
                echo "ERROR: dpkg/apt lock held after $max_attempts attempts; aborting."
                return "$status"
            fi
            echo "dpkg/apt lock held by another process, retrying in ${sleep_seconds}s (attempt ${attempt}/${max_attempts})..."
            sleep "$sleep_seconds"
            attempt=$((attempt + 1))
            continue
        fi
        return "$status"
    done
}

# ===================================
# Performance Optimization: Parallel Downloads
# ===================================
if [ "$OS_FAMILY" = "debian" ]; then
    # Enable parallel apt downloads (3 concurrent connections per package)
    echo 'Acquire::Queue-Mode "host";' > /etc/apt/apt.conf.d/99parallel
    echo 'Acquire::http::Pipeline-Depth "5";' >> /etc/apt/apt.conf.d/99parallel
    echo 'APT::Acquire::Max-FutureTime "86400";' >> /etc/apt/apt.conf.d/99parallel
else
    # Enable parallel yum downloads
    if ! grep -q "^max_parallel_downloads" /etc/yum.conf 2>/dev/null; then
        echo "max_parallel_downloads=10" >> /etc/yum.conf
    fi
fi

PKG_UPDATE_GUARD="/var/lib/geusemaker/packages-updated"

pkg_update() {
    if [ "$OS_FAMILY" = "debian" ]; then
        with_dpkg_lock_retry apt-get update -y
    else
        yum update -y
    fi
}

pkg_update_once() {
    if [ -f "$PKG_UPDATE_GUARD" ]; then
        return
    fi
    pkg_update
    touch "$PKG_UPDATE_GUARD"
}

pkg_install() {
    if [ "$OS_FAMILY" = "debian" ]; then
        with_dpkg_lock_retry apt-get install -y "$@"
    else
        yum install -y "$@"
    fi
}

get_primary_user() {
    if id -u ec2-user >/dev/null 2>&1; then
        echo "ec2-user"
    elif id -u ubuntu >/dev/null 2>&1; then
        echo "ubuntu"
    else
        # Fallback to first non-root user with UID >= 1000
        awk -F: '$3 >= 1000 {print $1; exit}' /etc/passwd
    fi
}

# ===================================
# curl and Metadata Service Helpers
# ===================================

verify_curl() {
    # Verify curl is installed and functional
    if ! command -v curl >/dev/null 2>&1; then
        echo "ERROR: curl is not installed or not in PATH"
        return 1
    fi

    # Test basic curl functionality
    if ! curl --version >/dev/null 2>&1; then
        echo "ERROR: curl is installed but not functional"
        return 1
    fi

    return 0
}

fetch_metadata() {
    # Fetch from EC2 metadata service with retries and timeouts
    # Usage: fetch_metadata <path> [max_attempts] [retry_delay]
    # Example: fetch_metadata "placement/availability-zone" 10 2

    local metadata_path="$1"
    local max_attempts="${2:-10}"
    local retry_delay="${3:-2}"
    local timeout="${4:-5}"

    # Ensure curl is available
    if ! verify_curl; then
        echo "ERROR: curl not available for metadata fetch" >&2
        return 1
    fi

    local attempt=1
    local token=""

    # Get IMDSv2 token for secure metadata access (with retries)
    while [ "$attempt" -le "$max_attempts" ]; do
        token=$(curl -sf -X PUT "http://169.254.169.254/latest/api/token" \
            -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" \
            --connect-timeout "$timeout" \
            --max-time "$((timeout * 2))" 2>/dev/null || true)

        if [ -n "$token" ]; then
            break
        fi

        if [ "$attempt" -ge "$max_attempts" ]; then
            echo "ERROR: Failed to obtain IMDSv2 token after $max_attempts attempts" >&2
            return 1
        fi

        echo "Metadata service not ready, retrying in ${retry_delay}s (attempt ${attempt}/${max_attempts})..." >&2
        sleep "$retry_delay"
        attempt=$((attempt + 1))
    done

    # Fetch metadata using the token
    attempt=1
    local result=""
    while [ "$attempt" -le "$max_attempts" ]; do
        result=$(curl -sf -H "X-aws-ec2-metadata-token: $token" \
            "http://169.254.169.254/latest/meta-data/${metadata_path}" \
            --connect-timeout "$timeout" \
            --max-time "$((timeout * 2))" 2>/dev/null || true)

        if [ -n "$result" ]; then
            echo "$result"
            return 0
        fi

        if [ "$attempt" -ge "$max_attempts" ]; then
            echo "ERROR: Failed to fetch metadata '${metadata_path}' after $max_attempts attempts" >&2
            return 1
        fi

        echo "Metadata fetch failed, retrying in ${retry_delay}s (attempt ${attempt}/${max_attempts})..." >&2
        sleep "$retry_delay"
        attempt=$((attempt + 1))
    done

    return 1
}

# ===================================
# Core System Dependencies
# ===================================
echo "Installing core system dependencies..."
pkg_update_once

# Batch install all core dependencies for performance (single apt/yum transaction)
if [ "$OS_FAMILY" = "debian" ]; then
    # Debian/Ubuntu: Install all dependencies in one transaction (handle fuse package rename on 24.04)
    fuse_pkg=""
    if apt-cache show libfuse2 >/dev/null 2>&1; then
        fuse_pkg="libfuse2"
    elif apt-cache show libfuse2t64 >/dev/null 2>&1; then
        fuse_pkg="libfuse2t64"
    fi
    pkg_install curl ca-certificates util-linux coreutils nfs-common stunnel4 fuse ${fuse_pkg:+$fuse_pkg}
else
    # Amazon Linux: Replace curl-minimal with full curl (AL2023 ships with curl-minimal)
    # Use --allowerasing to allow yum to replace curl-minimal with curl
    yum install -y curl nfs-utils --allowerasing || true
fi

# Verify curl installation and functionality
if ! verify_curl; then
    echo "ERROR: curl installation verification failed"
    echo "Attempting to reinstall curl..."
    if [ "$OS_FAMILY" = "debian" ]; then
        apt-get remove -y curl-minimal 2>/dev/null || true
        pkg_install curl
    else
        yum remove -y curl-minimal 2>/dev/null || true
        yum install -y curl --allowerasing
    fi

    # Final verification
    if ! verify_curl; then
        echo "FATAL: curl installation failed after retry"
        exit 1
    fi
fi

echo "Core dependencies installed successfully (curl verified)"

{% if enable_https and tier == "dev" %}
# ===================================
# HTTPS/TLS Setup (Tier 1 - Self-Signed)
# ===================================
echo "Setting up HTTPS with self-signed certificate..."

# Install openssl if not present
if [ "$OS_FAMILY" = "debian" ]; then
    pkg_install openssl
else
    yum install -y openssl
fi

# Create SSL directory
mkdir -p /etc/nginx/ssl
chmod 700 /etc/nginx/ssl

# Fetch public IP for certificate CN
PUBLIC_IP="{{ public_ip }}"
if [ -z "$PUBLIC_IP" ]; then
    PUBLIC_IP=$(fetch_metadata "public-ipv4" 5 2 3 || echo "localhost")
fi

# Generate self-signed certificate valid for 1 year
echo "Generating self-signed SSL certificate for IP: $PUBLIC_IP"
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/nginx/ssl/selfsigned.key \
    -out /etc/nginx/ssl/selfsigned.crt \
    -subj "/C=US/ST=State/L=City/O=GeuseMaker/OU=Development/CN=$PUBLIC_IP" \
    2>&1 || {
        echo "ERROR: Failed to generate self-signed certificate"
        exit 1
    }

# Set appropriate permissions
chmod 600 /etc/nginx/ssl/selfsigned.key
chmod 644 /etc/nginx/ssl/selfsigned.crt

# Verify certificate was created
if [ ! -f /etc/nginx/ssl/selfsigned.crt ] || [ ! -f /etc/nginx/ssl/selfsigned.key ]; then
    echo "ERROR: SSL certificate files not found after generation"
    exit 1
fi

# Create NGINX configuration directory
mkdir -p /etc/nginx/conf.d

# Deploy NGINX SSL configuration
# NOTE: nginx will be installed and started AFTER Docker services are running
# This avoids 'host not found' errors when nginx -t tries to resolve container hostnames
cat > /etc/nginx/conf.d/default.conf <<"EOF_NGINX_CONFIG"
{% include 'nginx-ssl.conf.j2' %}

EOF_NGINX_CONFIG

echo "Self-signed SSL certificate generated successfully"
echo "Certificate: /etc/nginx/ssl/selfsigned.crt"
echo "Private key: /etc/nginx/ssl/selfsigned.key"
echo "NGINX configuration created at /etc/nginx/conf.d/default.conf"
echo "NGINX will be installed and started after Docker services are running"
{% else %}
echo "HTTPS not enabled or not Tier 1, skipping self-signed certificate generation"
{% endif %}
