# ===================================
# Docker Compose Service Setup
# ===================================

SERVICES_GUARD="/var/lib/geusemaker/services-started"
if [ -f "$SERVICES_GUARD" ]; then
    echo "Services already started, skipping"
else
    echo "Configuring Docker Compose services..."

    use_runtime_bundle="{{ 'true' if use_runtime_bundle else 'false' }}"

    run_compose() {
        local compose_dir
        compose_dir="$(dirname "$COMPOSE_FILE_PATH")"
        if [ ! -d "$compose_dir" ]; then
            echo "ERROR: Compose directory not found: $compose_dir"
            exit 1
        fi
        if command -v docker-compose >/dev/null 2>&1; then
            (cd "$compose_dir" && docker-compose -f "$COMPOSE_FILE_PATH" "$@")
        else
            (cd "$compose_dir" && docker compose -f "$COMPOSE_FILE_PATH" "$@")
        fi
    }

    write_runtime_env() {
        local env_dir
        env_dir="$(dirname "$RUNTIME_ENV_FILE")"
        mkdir -p "$env_dir"
        cat > "$RUNTIME_ENV_FILE" <<'EOF'
N8N_PORT={{ n8n_port }}
OLLAMA_PORT={{ ollama_port }}
QDRANT_PORT={{ qdrant_port }}
CRAWL4AI_PORT={{ crawl4ai_port }}
POSTGRES_PASSWORD={{ postgres_password }}
N8N_METRICS={{ "true" if tier == "automation" or tier == "gpu" else "false" }}
DOCKER_RUNTIME={{ "nvidia" if tier == "gpu" else "runc" }}
NVIDIA_VISIBLE_DEVICES={{ "all" if tier == "gpu" else "" }}
EOF
{% for key, value in custom_env.items() %}
        printf "%s\n" "{{ key }}={{ value }}" >> "$RUNTIME_ENV_FILE"
{% endfor %}

        if [ ! -f "$RUNTIME_ENV_FILE" ]; then
            echo "ERROR: Failed to create runtime env file at $RUNTIME_ENV_FILE"
            exit 1
        fi
        if ! grep -q "^POSTGRES_PASSWORD=" "$RUNTIME_ENV_FILE"; then
            echo "ERROR: POSTGRES_PASSWORD missing from $RUNTIME_ENV_FILE"
            exit 1
        fi
    }

    export_runtime_env() {
        if [ ! -f "$RUNTIME_ENV_FILE" ]; then
            echo "ERROR: Runtime env file not found at $RUNTIME_ENV_FILE"
            exit 1
        fi
        # shellcheck disable=SC2046
        set -a
        # Export all key=value pairs (supports basic lines without spaces)
        while IFS='=' read -r key value; do
            [ -z "$key" ] && continue
            case "$key" in
                \#*) continue ;;
            esac
            export "$key=$value"
        done < "$RUNTIME_ENV_FILE"
        set +a
    }

    write_compose_file() {
        cat > "$COMPOSE_FILE_PATH" <<'EOF'
version: "3.8"

services:
  n8n:
    image: n8nio/n8n:latest
    container_name: n8n
    restart: unless-stopped
    env_file:
      - ./runtime.env
    environment:
      - N8N_HOST=0.0.0.0
      - N8N_PORT=${N8N_PORT:-5678}
      - N8N_PROTOCOL=http
      - WEBHOOK_URL=http://localhost:${N8N_PORT:-5678}/
      - N8N_METRICS=${N8N_METRICS:-false}
      - N8N_SECURE_COOKIE=true
    ports:
      - "${N8N_PORT:-5678}:5678"
    volumes:
      - /mnt/efs/n8n:/home/node/.n8n
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:5678/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  ollama:
    image: ollama/ollama:latest
    container_name: ollama
    restart: unless-stopped
    env_file:
      - ./runtime.env
    runtime: ${DOCKER_RUNTIME:-runc}
    environment:
      - NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-}
    ports:
      - "${OLLAMA_PORT:-11434}:11434"
    volumes:
      - /mnt/efs/ollama:/root/.ollama
{% if tier == "gpu" %}
    # GPU device reservations (requires Docker Compose 1.28.0+ and nvidia-container-toolkit)
    # Only enabled for GPU tier deployments
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
{% endif %}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:11434/api/tags"]
      interval: 30s
      timeout: 10s
      retries: 3

  qdrant:
    image: qdrant/qdrant:latest
    container_name: qdrant
    restart: unless-stopped
    env_file:
      - ./runtime.env
    ports:
      - "${QDRANT_PORT:-6333}:6333"
      - "6334:6334"
    volumes:
      - /mnt/efs/qdrant:/qdrant/storage
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:6333/healthz"]
      interval: 30s
      timeout: 10s
      retries: 3

  crawl4ai:
    image: unclecode/crawl4ai:latest
    container_name: crawl4ai
    restart: unless-stopped
    env_file:
      - ./runtime.env
    ports:
      - "${CRAWL4AI_PORT:-11235}:11235"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:11235/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:15
    container_name: postgres
    restart: unless-stopped
    env_file:
      - ./runtime.env
    environment:
      - POSTGRES_DB=geusemaker
      - POSTGRES_USER=geusemaker
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?POSTGRES_PASSWORD required}
    volumes:
      - /mnt/efs/postgres:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U geusemaker"]
      interval: 30s
      timeout: 10s
      retries: 3
EOF
    }

    load_prebaked_images() {
        local images_dir="${GEUSEMAKER_RUNTIME_DIR:-/opt/geusemaker/runtime}/images"
        if [ ! -d "$images_dir" ]; then
            return
        fi
        shopt -s nullglob
        for tarball in "$images_dir"/*.tar "$images_dir"/*.tar.gz; do
            [ -e "$tarball" ] || continue
            echo "Loading pre-baked Docker image $tarball"
            docker load -i "$tarball" || true
        done
        shopt -u nullglob
    }

    write_runtime_env
    export_runtime_env

    if [ "$use_runtime_bundle" = "true" ]; then
        if [ ! -f "$COMPOSE_FILE_PATH" ]; then
            echo "ERROR: Runtime bundle compose not found at $COMPOSE_FILE_PATH"
            exit 1
        fi
    else
        write_compose_file
    fi

    load_prebaked_images

    echo "Pre-pulling Docker images to EFS-backed data directory..."
    run_compose pull

    wait_for_containers_running() {
        local max_attempts=30
        local attempt=1
        local delay=2
        local expected_containers=("n8n" "ollama" "qdrant" "crawl4ai" "postgres")

        echo "Waiting for containers to reach running state..."

        while [ $attempt -le $max_attempts ]; do
            local all_running=true
            local running_count=0

            for container in "${expected_containers[@]}"; do
                if docker inspect "$container" >/dev/null 2>&1; then
                    local state
                    state=$(docker inspect -f '{% raw %}{{.State.Status}}{% endraw %}' "$container" 2>/dev/null || echo "unknown")
                    if [ "$state" = "running" ]; then
                        running_count=$((running_count + 1))
                    else
                        all_running=false
                        echo "  Container $container state: $state (attempt $attempt/$max_attempts)"
                    fi
                else
                    all_running=false
                    echo "  Container $container not found (attempt $attempt/$max_attempts)"
                fi
            done

            if [ "$all_running" = true ]; then
                echo "All $running_count containers are running"
                return 0
            fi

            if [ $attempt -lt $max_attempts ]; then
                sleep $delay
                # Exponential backoff up to 10 seconds
                if [ $delay -lt 10 ]; then
                    delay=$((delay + 1))
                fi
            fi
            attempt=$((attempt + 1))
        done

        echo "ERROR: Not all containers reached running state after $max_attempts attempts"
        run_compose ps
        return 1
    }

    verify_docker_network() {
        local max_attempts=20
        local attempt=1
        local delay=3

        echo "Verifying Docker network hostname resolution..."

        while [ $attempt -le $max_attempts ]; do
            # Test hostname resolution from n8n container to other services
            local network_ready=true

            # Check if n8n can resolve postgres hostname (critical for n8n database)
            if ! docker exec n8n getent hosts postgres >/dev/null 2>&1; then
                network_ready=false
                echo "  DNS resolution not ready: n8n -> postgres (attempt $attempt/$max_attempts)"
            fi

            # Check if n8n can resolve ollama hostname (critical for AI workflows)
            if ! docker exec n8n getent hosts ollama >/dev/null 2>&1; then
                network_ready=false
                echo "  DNS resolution not ready: n8n -> ollama (attempt $attempt/$max_attempts)"
            fi

            if [ "$network_ready" = true ]; then
                echo "Docker network hostname resolution verified"
                return 0
            fi

            if [ $attempt -lt $max_attempts ]; then
                sleep $delay
            fi
            attempt=$((attempt + 1))
        done

        echo "ERROR: Docker network hostname resolution failed after $max_attempts attempts"
        echo "Network diagnostics:"
        docker network ls
        docker network inspect "$(docker inspect n8n -f '{% raw %}{{range .NetworkSettings.Networks}}{{.NetworkID}}{{end}}{% endraw %}' 2>/dev/null || echo bridge)" || true
        return 1
    }

    echo "Starting Docker Compose services..."
    run_compose up -d

    # Wait for all containers to reach running state with retry logic
    if ! wait_for_containers_running; then
        echo "ERROR: Container startup failed"
        exit 1
    fi

    # Verify Docker network is ready for hostname resolution
    if ! verify_docker_network; then
        echo "WARNING: Docker network verification failed, but containers are running"
        echo "Services may experience connectivity issues until network stabilizes"
    fi

    # Display final container status
    echo "Services started successfully:"
    run_compose ps

    touch "$SERVICES_GUARD"
fi
