# Story 10.1: HTTPS/TLS Implementation Across All Tiers

**Epic:** 10 - Security & Compliance
**Story:** 10.1
**Status:** Draft
**Priority:** P0 - Critical Security Issue
**Estimated Effort:** 2-3 days

## Context

Currently, all GeuseMaker deployments use HTTP with disabled secure cookies (`N8N_SECURE_COOKIE=false`), exposing session tokens and credentials to interception. This story implements HTTPS/TLS across all three deployment tiers to enable secure cookie flags and encrypt all traffic.

## Problem Statement

**Security Vulnerabilities:**
- Session cookies transmitted over HTTP (vulnerable to session hijacking)
- n8n webhooks and API tokens exposed in plaintext
- PostgreSQL credentials visible in unencrypted traffic
- No protection against man-in-the-middle attacks

**Current State:**
- `docker-compose.yml:16` - `N8N_SECURE_COOKIE=false`
- ALB defaults to HTTP on port 80
- CloudFront allows HTTP and uses `http-only` origin protocol
- No certificate management infrastructure

## Goals

1. **Enable HTTPS for all tiers** (dev, production, GPU)
2. **Enable secure cookie flags** (`N8N_SECURE_COOKIE=true`)
3. **Encrypt all client-server communication**
4. **Provide tier-appropriate certificate management**
5. **Maintain zero-cost option for development** (self-signed certs)

## Technical Design

### Architecture by Tier

#### Tier 1: Development (Self-Signed Certificates)

```
┌──────────────────────────────────────────────────────┐
│ Client (Browser)                                     │
└─────────────────┬────────────────────────────────────┘
                  │ HTTPS (443) - Self-signed cert
                  │ Browser warning expected
┌─────────────────▼────────────────────────────────────┐
│ EC2 Instance                                         │
│  ┌────────────────────────────────────────────────┐  │
│  │ NGINX Reverse Proxy (Port 443)                 │  │
│  │  - Self-signed TLS certificate                 │  │
│  │  - Routes:                                     │  │
│  │    / → n8n:5678                               │  │
│  │    /api/ollama → ollama:11434                 │  │
│  │    /qdrant → qdrant:6333                      │  │
│  └──────────────────┬─────────────────────────────┘  │
│                     │ HTTP (localhost)                │
│  ┌──────────────────▼─────────────────────────────┐  │
│  │ Docker Services (HTTP on localhost)           │  │
│  │  - n8n:5678                                    │  │
│  │  - ollama:11434                                │  │
│  │  - qdrant:6333                                 │  │
│  │  - crawl4ai:11235                              │  │
│  │  - postgres:5432                               │  │
│  └────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────┘
```

**Benefits:**
- ✅ Zero cost (no ACM certificate required)
- ✅ Works with public IPs (no custom domain needed)
- ✅ Immediate deployment (no DNS configuration)
- ✅ Perfect for dev/testing environments
- ⚠️ Browser warnings (acceptable for development)

**Implementation:**
1. Add NGINX container to `docker-compose.yml`
2. Generate self-signed certificate in UserData script
3. Configure NGINX reverse proxy with SSL
4. Update security group to allow port 443
5. Set `N8N_SECURE_COOKIE=true` in environment

#### Tier 2: Production with ALB (AWS Certificate Manager)

```
┌──────────────────────────────────────────────────────┐
│ Client (Browser)                                     │
└─────────────────┬────────────────────────────────────┘
                  │ HTTPS (443)
                  │ ACM certificate (trusted CA)
┌─────────────────▼────────────────────────────────────┐
│ Application Load Balancer                            │
│  - HTTPS Listener (Port 443) with ACM cert           │
│  - HTTP Listener (Port 80) → redirect to HTTPS       │
│  - Health checks over HTTP                           │
└─────────────────┬────────────────────────────────────┘
                  │ HTTP (internal VPC)
┌─────────────────▼────────────────────────────────────┐
│ Target Group (EC2 Instances)                         │
│  - Health check: HTTP:5678/healthz                   │
│  - Backend: HTTP (no internal TLS needed)            │
│                                                       │
│  Docker Services:                                    │
│    - n8n:5678 (HTTP)                                 │
│    - ollama:11434 (HTTP)                             │
│    - qdrant:6333 (HTTP)                              │
└──────────────────────────────────────────────────────┘
```

**Benefits:**
- ✅ Free AWS-managed certificates (no cost)
- ✅ Automatic certificate renewal
- ✅ Trusted CA certificates (no browser warnings)
- ✅ High availability with multi-AZ ALB
- ⚠️ Requires custom domain for ACM validation

**Implementation:**
1. Add `certificate_arn` field to `DeploymentConfig`
2. Create ACM certificate (manual or automated via ACM)
3. Update `ALBService.create_listener()` to support HTTPS
4. Add HTTP→HTTPS redirect listener
5. Update security group to allow port 443
6. Set `N8N_SECURE_COOKIE=true` in environment

#### Tier 3: GPU with CloudFront (Global HTTPS)

```
┌──────────────────────────────────────────────────────┐
│ Client (Browser) - Global                            │
└─────────────────┬────────────────────────────────────┘
                  │ HTTPS (443)
                  │ ACM certificate (us-east-1)
┌─────────────────▼────────────────────────────────────┐
│ CloudFront Distribution (Global Edge Locations)      │
│  - Viewer Protocol: redirect-to-https                │
│  - ACM Certificate (must be in us-east-1)            │
│  - Origin Protocol: https-only                       │
└─────────────────┬────────────────────────────────────┘
                  │ HTTPS (443)
┌─────────────────▼────────────────────────────────────┐
│ Application Load Balancer (Regional)                 │
│  - HTTPS Listener (Port 443) with ACM cert           │
│  - HTTP Listener (Port 80) → redirect to HTTPS       │
└─────────────────┬────────────────────────────────────┘
                  │ HTTP (internal VPC)
┌─────────────────▼────────────────────────────────────┐
│ Target Group (GPU EC2 Instances)                     │
│  - Backend: HTTP (internal VPC)                      │
└──────────────────────────────────────────────────────┘
```

**Benefits:**
- ✅ End-to-end encryption from client to ALB
- ✅ Global edge caching with HTTPS
- ✅ Trusted certificates at both CloudFront and ALB
- ✅ DDoS protection at CloudFront layer
- ⚠️ Requires 2 ACM certificates (us-east-1 for CloudFront, regional for ALB)

**Implementation:**
1. Update `CloudFrontService` to enforce `redirect-to-https`
2. Change `OriginProtocolPolicy` to `https-only`
3. Add ACM certificate ARN for CloudFront (us-east-1)
4. Add ACM certificate ARN for ALB (deployment region)
5. Set `N8N_SECURE_COOKIE=true` in environment

## Implementation Tasks

### Phase 1: Model and Configuration Updates
- [ ] Add certificate fields to `DeploymentConfig` model
  ```python
  # New fields in DeploymentConfig
  enable_https: bool = True  # Default to HTTPS
  tier1_use_self_signed: bool = True  # Self-signed for dev
  alb_certificate_arn: str | None = None  # ACM cert for ALB (Tier 2/3)
  cloudfront_certificate_arn: str | None = None  # ACM cert for CloudFront (Tier 3, us-east-1 only)
  force_https_redirect: bool = True  # Redirect HTTP → HTTPS
  ```

- [ ] Update `DeploymentState` to track HTTPS endpoints
  ```python
  # New fields in DeploymentState
  https_enabled: bool
  https_endpoint: str | None  # https://... URL
  certificate_arn: str | None
  nginx_proxy_enabled: bool  # Tier 1 only
  ```

### Phase 2: Security Group Updates
- [ ] Update `SecurityGroupService` to add port 443 rules
  ```python
  # Add HTTPS ingress rule
  {
      "IpProtocol": "tcp",
      "FromPort": 443,
      "ToPort": 443,
      "IpRanges": [{"CidrIp": "0.0.0.0/0"}],
      "Ipv6Ranges": [{"CidrIpv6": "::/0"}],
  }
  ```

### Phase 3: Tier 1 Implementation (NGINX with Self-Signed Cert)
- [ ] Add NGINX configuration template (`nginx-ssl.conf.j2`)
- [ ] Update `docker-compose.yml` to add NGINX service
  ```yaml
  nginx:
    image: nginx:alpine
    container_name: nginx
    restart: unless-stopped
    ports:
      - "443:443"
      - "80:80"  # Redirect to HTTPS
    volumes:
      - /etc/nginx/conf.d:/etc/nginx/conf.d:ro
      - /etc/nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - n8n
      - ollama
      - qdrant
  ```

- [ ] Add self-signed certificate generation to UserData
  ```bash
  # Generate self-signed certificate
  openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout /etc/nginx/ssl/selfsigned.key \
    -out /etc/nginx/ssl/selfsigned.crt \
    -subj "/C=US/ST=State/L=City/O=GeuseMaker/CN=${PUBLIC_IP}"
  ```

- [ ] Update n8n environment: `N8N_SECURE_COOKIE=true`
- [ ] Update `WEBHOOK_URL` to use HTTPS

### Phase 4: Tier 2 Implementation (ALB with ACM)
- [ ] Update `ALBService.create_listener()` to accept `certificate_arn` parameter
  ```python
  def create_https_listener(
      self,
      load_balancer_arn: str,
      target_group_arn: str,
      certificate_arn: str,
      port: int = 443,
  ) -> dict[str, Any]:
      """Create HTTPS listener with ACM certificate."""
      def _call() -> dict[str, Any]:
          return self._elbv2.create_listener(
              LoadBalancerArn=load_balancer_arn,
              Protocol="HTTPS",
              Port=port,
              Certificates=[{"CertificateArn": certificate_arn}],
              DefaultActions=[
                  {"Type": "forward", "TargetGroupArn": target_group_arn}
              ],
          )
      return self._safe_call(_call)
  ```

- [ ] Add HTTP→HTTPS redirect listener (port 80)
  ```python
  def create_redirect_listener(
      self,
      load_balancer_arn: str,
      port: int = 80,
  ) -> dict[str, Any]:
      """Create HTTP listener that redirects to HTTPS."""
      def _call() -> dict[str, Any]:
          return self._elbv2.create_listener(
              LoadBalancerArn=load_balancer_arn,
              Protocol="HTTP",
              Port=port,
              DefaultActions=[
                  {
                      "Type": "redirect",
                      "RedirectConfig": {
                          "Protocol": "HTTPS",
                          "Port": "443",
                          "StatusCode": "HTTP_301",
                      },
                  }
              ],
          )
      return self._safe_call(_call)
  ```

- [ ] Update `Tier2Orchestrator` to create HTTPS listener when `certificate_arn` provided
- [ ] Update health checks to use HTTP (internal traffic remains HTTP)
- [ ] Update n8n environment: `N8N_SECURE_COOKIE=true`

### Phase 5: Tier 3 Implementation (CloudFront HTTPS)
- [ ] Update `CloudFrontService.create_distribution_with_alb_origin()`
  - Change `ViewerProtocolPolicy` from `"allow-all"` to `"redirect-to-https"`
  - Change `OriginProtocolPolicy` from `"http-only"` to `"https-only"`
  - Add ACM certificate ARN validation (must be us-east-1 for CloudFront)

- [ ] Update `Tier3Orchestrator` to enforce HTTPS
  ```python
  # Validate CloudFront certificate is in us-east-1
  if config.cloudfront_certificate_arn:
      if not config.cloudfront_certificate_arn.startswith("arn:aws:acm:us-east-1:"):
          raise ValidationError(
              "CloudFront certificates must be in us-east-1 region. "
              "Create ACM certificate in us-east-1 for CloudFront."
          )
  ```

- [ ] Update n8n environment: `N8N_SECURE_COOKIE=true`

### Phase 6: CLI and Interactive Flow Updates
- [ ] Add certificate ARN prompts to interactive deployment flow
  ```python
  # Tier 2/3: Prompt for ACM certificate ARN
  certificate_arn = questionary.text(
      "ACM Certificate ARN (optional, enables HTTPS):",
      default="",
  ).ask()

  if not certificate_arn:
      console.print(
          "[yellow]⚠️  No certificate provided. Tier 1 will use self-signed cert. "
          "Tier 2/3 require ACM certificate for HTTPS.[/yellow]"
      )
  ```

- [ ] Add certificate validation helper
  ```python
  def validate_acm_certificate(arn: str, region: str) -> bool:
      """Validate ACM certificate exists and is in correct region."""
      acm = boto3.client("acm", region_name=region)
      try:
          resp = acm.describe_certificate(CertificateArn=arn)
          status = resp["Certificate"]["Status"]
          if status != "ISSUED":
              raise ValueError(f"Certificate status is {status}, must be ISSUED")
          return True
      except Exception as e:
          raise ValueError(f"Invalid ACM certificate: {e}")
  ```

### Phase 7: Testing
- [ ] Unit tests for NGINX configuration generation
- [ ] Unit tests for HTTPS listener creation (ALB)
- [ ] Unit tests for CloudFront HTTPS enforcement
- [ ] Integration test: Deploy Tier 1 with self-signed cert
- [ ] Integration test: Deploy Tier 2 with ACM cert
- [ ] Integration test: Deploy Tier 3 with dual ACM certs
- [ ] Verify secure cookies are enabled in browser DevTools
- [ ] Verify HTTP→HTTPS redirects work correctly
- [ ] Test certificate rotation (update ACM cert ARN)

## Acceptance Criteria

- [ ] **Tier 1**: Deploys with self-signed NGINX certificate, `N8N_SECURE_COOKIE=true`
- [ ] **Tier 2**: Deploys with ACM certificate on ALB, HTTP redirects to HTTPS
- [ ] **Tier 3**: Deploys with ACM certs on CloudFront and ALB, end-to-end HTTPS
- [ ] **All Tiers**: `N8N_SECURE_COOKIE=true` set in docker-compose.yml
- [ ] **Security**: All session cookies have `Secure` flag enabled
- [ ] **Security**: n8n webhooks use HTTPS URLs
- [ ] **Security**: No plaintext credentials transmitted over HTTP
- [ ] **Validation**: Pre-deployment validation checks certificate ARNs
- [ ] **Documentation**: CLAUDE.md updated with HTTPS/TLS patterns
- [ ] **Tests**: All unit and integration tests pass

## Certificate Management Guide

### For Development (Tier 1)
```bash
# No action required - self-signed cert generated automatically
geusemaker deploy --tier 1
```

### For Production (Tier 2/3)
```bash
# Step 1: Request ACM certificate (one-time)
aws acm request-certificate \
  --domain-name "*.example.com" \
  --subject-alternative-names "example.com" \
  --validation-method DNS \
  --region us-east-1

# Step 2: Validate domain ownership (add DNS CNAME records)
aws acm describe-certificate --certificate-arn arn:aws:acm:us-east-1:123456789012:certificate/abc123

# Step 3: Wait for certificate to be issued
aws acm wait certificate-validated --certificate-arn arn:aws:acm:us-east-1:123456789012:certificate/abc123

# Step 4: Deploy with certificate ARN
geusemaker deploy --tier 2 \
  --alb-certificate-arn arn:aws:acm:us-east-1:123456789012:certificate/abc123
```

### For Tier 3 (CloudFront + ALB)
```bash
# CloudFront requires certificate in us-east-1
# ALB uses certificate in deployment region (can be different)

geusemaker deploy --tier 3 \
  --cloudfront-certificate-arn arn:aws:acm:us-east-1:123456789012:certificate/abc123 \
  --alb-certificate-arn arn:aws:acm:us-west-2:123456789012:certificate/def456
```

## Cost Implications

| Tier | Cost Impact | Notes |
|------|-------------|-------|
| Tier 1 | $0 | Self-signed certificates are free |
| Tier 2 | $0 | ACM certificates are free |
| Tier 3 | $0 | ACM certificates are free |

**Note:** ACM certificates are free, but you must own a domain name (~$12/year for `.com`). Tier 1 works without a domain using self-signed certificates.

## Security Improvements

| Metric | Before | After | Impact |
|--------|--------|-------|--------|
| Session Security | ❌ HTTP, no Secure flag | ✅ HTTPS, Secure flag | Prevents session hijacking |
| Cookie Security | ❌ `N8N_SECURE_COOKIE=false` | ✅ `N8N_SECURE_COOKIE=true` | Cookies only over HTTPS |
| Credential Exposure | ❌ Plaintext PostgreSQL passwords | ✅ Encrypted in transit | Prevents credential theft |
| Webhook Security | ❌ HTTP webhooks | ✅ HTTPS webhooks | Prevents webhook spoofing |
| MITM Protection | ❌ No encryption | ✅ TLS 1.2+ encryption | Prevents eavesdropping |

## Migration Path for Existing Deployments

```bash
# Step 1: Request ACM certificate (if Tier 2/3)
# (see Certificate Management Guide above)

# Step 2: Update deployment to enable HTTPS
geusemaker update --stack-name my-stack \
  --enable-https \
  --alb-certificate-arn arn:aws:acm:us-east-1:123456789012:certificate/abc123

# Step 3: Verify HTTPS is working
geusemaker status --stack-name my-stack
# Output: https://my-stack-alb-123456.us-east-1.elb.amazonaws.com

# Step 4: Update n8n webhooks to use HTTPS URLs
# (webhooks will automatically use new HTTPS endpoint)
```

## References

- **Epic 10 Story**: Enhanced Network Security
- **AWS ACM**: https://docs.aws.amazon.com/acm/
- **n8n Secure Cookies**: https://docs.n8n.io/hosting/configuration/environment-variables/
- **ALB HTTPS Listeners**: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html
- **CloudFront HTTPS**: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html

## Files Modified

- `geusemaker/models/deployment.py` - Add HTTPS config fields
- `geusemaker/services/alb.py` - Add HTTPS listener methods
- `geusemaker/services/cloudfront.py` - Update to enforce HTTPS
- `geusemaker/services/sg.py` - Add port 443 ingress rule
- `geusemaker/orchestration/tier1.py` - Add NGINX proxy with self-signed cert
- `geusemaker/orchestration/tier2.py` - Add HTTPS listener creation
- `geusemaker/orchestration/tier3.py` - Update CloudFront HTTPS enforcement
- `geusemaker/runtime_assets/docker-compose.yml` - Add NGINX service, enable secure cookies
- `geusemaker/services/userdata/templates/base.sh.j2` - Add self-signed cert generation
- `geusemaker/services/userdata/templates/nginx-ssl.conf.j2` - New NGINX SSL config template

## Implementation Priority

**P0 - Critical** (Week 1):
1. Phase 1: Model updates (certificate ARN fields)
2. Phase 2: Security group updates (port 443)
3. Phase 6: CLI updates (certificate prompts)

**P1 - High** (Week 1-2):
4. Phase 3: Tier 1 NGINX implementation
5. Phase 4: Tier 2 ALB HTTPS implementation

**P2 - Medium** (Week 2):
6. Phase 5: Tier 3 CloudFront HTTPS implementation
7. Phase 7: Testing and validation

**Estimated Timeline:** 2-3 days for full implementation across all tiers
